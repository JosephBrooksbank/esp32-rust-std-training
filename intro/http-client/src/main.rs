use anyhow::{bail, Result};
use core::str;
use embedded_svc::{
    http::{client::Client, Method},
    io::Read,
};
use esp_idf_svc::{
    eventloop::EspSystemEventLoop,
    hal::prelude::Peripherals,
    http::client::{Configuration, EspHttpConnection},
    log,
};
use std::u16;
use wifi::wifi;

#[toml_cfg::toml_config]
pub struct Config {
    #[default("Wokwi-GUEST")]
    wifi_ssid: &'static str,
    #[default("")]
    wifi_psk: &'static str,
}

#[derive(Debug)]
enum HttpError {
    Redirection(u16),
    Client(u16),
    Server(u16),
}

impl std::fmt::Display for HttpError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            Self::Redirection(code) => write!(f, "{} Redirection", code),
            Self::Client(code) => write!(f, "{} Client Error", code),
            Self::Server(code) => write!(f, "{} Server Error!", code),
        }
    }
}

impl std::error::Error for HttpError {
    fn cause(&self) -> Option<&dyn std::error::Error> {
        self.source()
    }
}

fn main() -> Result<()> {
    esp_idf_svc::sys::link_patches();
    esp_idf_svc::log::EspLogger::initialize_default();

    let peripherals = Peripherals::take().unwrap();
    let sysloop = EspSystemEventLoop::take()?;

    // The constant `CONFIG` is auto-generated by `toml_config`.
    let app_config = CONFIG;

    // Connect to the Wi-Fi network
    let _wifi = wifi(
        app_config.wifi_ssid,
        app_config.wifi_psk,
        peripherals.modem,
        sysloop,
    )?;

    get("http://neverssl.com/")?;

    Ok(())
}

fn get(url: impl AsRef<str>) -> anyhow::Result<()> {
    // 1. Create a new EspHttpConnection with default Configuration. (Check documentation)
    let http_connection = EspHttpConnection::new(&Configuration::default()).unwrap();

    // 2. Get a client using the embedded_svc Client::wrap method. (Check documentation)
    let mut http_client = Client::wrap(http_connection);

    // 3. Open a GET request to `url`
    let headers = [("accept", "text/plain")];
    let request = http_client
        .request(Method::Get, url.as_ref(), &headers)
        .unwrap();

    // 4. Submit the request and check the status code of the response.
    // let response = request...;
    let response = request.submit().unwrap();
    let status = response.status();
    // let status = ...;
    println!("Response code: {}\n", status);

    match status {
        // Successful http status codes are in the 200..=299 range.
        200..=299 => {
            // 5. If the status is OK, read response data chunk by chunk into a buffer and print it until done.

            let mut total = 0;
            let mut buf = [0_u8; 256];
            let mut offset = 0;
            let mut reader = response;
            loop {
                let num_bytes = Read::read(&mut reader, &mut buf[offset..]);
                match num_bytes {
                    Ok(size) => {
                        // A return of Ok(0) indicates the reader has nothing left
                        if size == 0 {
                            break;
                        }
                        // track number of bytes read
                        total += size;

                        // attempt to read from buffer from start -> end of data as indicated by
                        // reader for current amount, into utf characters.

                        // we also need to include the offset from the past read incase there were
                        // any partial characters
                        let size_plus_offset = size + offset;
                        match str::from_utf8(&buf[..size]) {
                            Ok(text) => {
                                print!("{}", text);
                            }
                            Err(error) => {
                                // The buffer contains invalid UTF data. This could be either
                                // due to the data being actual bad data, or maybe the reader
                                // only returned part of a valid UTF character, or some valid
                                // characters and then an invalid character.
                                // note- at this point I miss arduino httpClient which Just Works ðŸ˜­
                                let valid_up_to = error.valid_up_to();

                                unsafe {
                                    // my first unsafe block! the error code already told us that
                                    // the UTF data up to this index is valid, so we can tell the
                                    // compiler it's fine. Another option would be to match again
                                    // but the error case of that match would never run, unless the
                                    // std lib str code is wrong, at which case we have bigger
                                    // problems
                                    print!("{}", str::from_utf8_unchecked(&buf[..valid_up_to]));
                                }
                                // move the invalid data to the start of the buffer, maybe to be
                                // combined with the next read
                                buf.copy_within(valid_up_to.., 0);
                                // set the offset for the next write so we don't overwrite this
                                // parital data
                                offset = size_plus_offset - valid_up_to;
                            }
                        }
                    }
                    Err(_) => bail!("Uh oh"),
                }
            }
            println!("Total: {} bytes", total);
        }
        300..=399 => {
            bail!(HttpError::Redirection(status))
        }
        400..=499 => bail!(HttpError::Client(status)),
        500..=599 => {
            bail!(HttpError::Server(status))
        }
        _ => bail!("Unexpected response code: {}", status),
    }

    Ok(())
}
